import * as fs from "fs";
import * as path from "path";

const ROOT = path.join(process.cwd(), "./json-schemas");

const FILES = [
  "behavior/animation_controllers/animation_controller.json",
  "behavior/animations/animations.json",
  "behavior/biomes/biomes.json",
  "behavior/blocks/blocks.json",
  "behavior/dialogue/dialogue.json",
  "behavior/entities/entities.json",
  "behavior/feature_rules/feature_rules.json",
  "behavior/features/features.json",
  "behavior/items/items.json",
  "behavior/loot_tables/loot_tables.json",
  "behavior/recipes/recipes.json",
  "behavior/spawn_rules/spawn_rules.json",
  "behavior/trading/trading.json",
  "resource/animation_controllers/animation_controller.json",
  "resource/animations/actor_animation.json",
  "resource/attachables/attachables.json",
  "resource/entity/entity.json",
  "resource/particles/particles.json",
  "resource/render_controllers/render_controllers.json",
];

function generateJsdoc(def) {
  let docs = "";

  if (def.default) {
    docs += `*@default ${JSON.stringify(def.default)}\n`;
  }

  if (def.examples) {
    for (const example of def.examples) {
      docs += `*@example\n*\`\`\`json\n*${JSON.stringify(
        example,
        undefined,
        2
      ).replaceAll("\n", "\n*")}\n*\`\`\`\n`;
    }
  }

  for (const [prop, val] of Object.entries(def)) {
    if (
      prop.startsWith("$") ||
      ["type", "title", "additionalProperties", "const", "default"].includes(
        prop
      ) ||
      typeof val === "object"
    )
      continue;

    docs += `*@${prop} ${val}\n`;
  }

  return docs.length ? `/**\n${docs}*/\n` : "";
}

function compileDefinition(def) {
  if (def.$ref) {
    return path.basename(def.$ref);
  }

  if (def.if) {
    return compileDefinition(def.then);
  }

  const anyOf = def.anyOf || def.oneOf || def.allOf;

  if (anyOf) {
    const unionTypes = [];
    for (const subdef of anyOf) {
      unionTypes.push(compileDefinition(subdef));
    }

    return unionTypes.join("|");
  }

  if (def.const) {
    return JSON.stringify(def.const);
  }

  if (Array.isArray(def.type)) {
    return def.type.join("|");
  }

  if (def.type === "array") {
    return `Array<${def.items ? compileDefinition(def.items) : "JsonType"}>`;
  }

  if (def.type === "object" || def.properties) {
    const required = def.required ?? [];

    let entries = "";

    if (def.properties) {
      for (const [prop, value] of Object.entries(def.properties)) {
        const propType = compileDefinition(value);
        entries += `${generateJsdoc(value)}"${prop}"${
          required.includes(prop) ? "" : "?"
        }:${propType};\n`;
      }
    }

    if (def.additionalProperties !== false) {
      entries += `[k:string]:${
        entries || !def.additionalProperties
          ? "any"
          : compileDefinition(def.additionalProperties)
      };\n`;
    }

    return entries ? `{\n${entries}}` : "Record<string,never>";
  }

  if (!def.type) {
    return def.pattern ? "string" : "JsonType";
  }

  return def.type;
}

let out =
  "export type JsonType=string|number|boolean|JsonType[]|{[k:string]:JsonType};\nexport type integer=number;";

function compileJsonSchema(schema) {
  let s = "";

  if (schema.definitions)
    for (const [name, def] of Object.entries(schema.definitions)) {
      // don't generate JSDoc because you won't be able to see it anyway
      s += `export type ${name}=${compileDefinition(def)};\n`;
    }

  return (
    s + `${generateJsdoc(schema)}export type Main=${compileDefinition(schema)};`
  );
}

for (const file of FILES) {
  const parsed = JSON.parse(fs.readFileSync(path.join(ROOT, file)));
  out += `\nexport namespace ${file[0]}_${path.basename(
    file,
    ".json"
  )} {\n${compileJsonSchema(parsed)}\n}`;
}

fs.writeFileSync(
  "minecraft_definition_types.d.ts",
  `// THIS FILE IS AUTOMATICALLY GENERATED. DO NOT MODIFY BY HAND!\n// SEE https://github.com/hopper-mcbe/generate-mc-type-defs\n// Generated on: ${new Date().toUTCString()}\n\n${out}`
);
